from __future__ import annotations

import asyncio
import logging
import sys
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, Iterable, List, Mapping, MutableMapping, Optional, Protocol

logger = logging.getLogger(__name__)


class MarketDataClient(Protocol):
    """Asynchronous provider for market snapshots consumed by bots."""

    async def fetch(self) -> Mapping[str, Any]:
        ...


class OrderPublisher(Protocol):
    """Publishes order intents generated by bots."""

    async def publish(self, intent: Mapping[str, Any]) -> None:
        ...


class StateStore(Protocol):
    """Abstract key-value store for bot state."""

    async def get(self, key: str, default: Any = None) -> Any:
        ...

    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        ...

    async def delete(self, key: str) -> None:
        ...


class ControlChannel(Protocol):
    """Receives control plane messages (e.g., STOP commands)."""

    async def receive(self, timeout: float = 0.0) -> Optional[Mapping[str, Any]]:
        ...


class HeartbeatPublisher(Protocol):
    """Emits liveness information to the platform."""

    async def publish(self, payload: Mapping[str, Any]) -> None:
        ...


class NullMarketDataClient:
    """Fallback market data client returning an empty snapshot."""

    async def fetch(self) -> Mapping[str, Any]:
        return {}


class StaticMarketDataClient:
    """Always returns the same snapshot."""

    def __init__(self, payload: Optional[Mapping[str, Any]] = None) -> None:
        self._payload = dict(payload or {})

    async def fetch(self) -> Mapping[str, Any]:
        await asyncio.sleep(0)
        return dict(self._payload)


class StdoutOrderPublisher:
    """
    Order publisher that logs intents to stdout. Useful for local testing
    or when running bots in dry-run mode.
    """

    def __init__(self) -> None:
        self._logger = logging.getLogger("bot.orders")

    async def publish(self, intent: Mapping[str, Any]) -> None:
        self._logger.info("order_intent", extra={"intent": dict(intent)})


class InMemoryStateStore:
    """Coroutine-friendly dictionary-backed store."""

    def __init__(self) -> None:
        self._values: MutableMapping[str, Any] = {}
        self._lock = asyncio.Lock()

    async def get(self, key: str, default: Any = None) -> Any:
        async with self._lock:
            return self._values.get(key, default)

    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:  # pragma: no cover - ttl unused placeholder
        async with self._lock:
            self._values[key] = value

    async def delete(self, key: str) -> None:
        async with self._lock:
            self._values.pop(key, None)


class NullControlChannel:
    """Control channel that never yields messages."""

    async def receive(self, timeout: float = 0.0) -> Optional[Mapping[str, Any]]:
        await asyncio.sleep(timeout)
        return None


class NullHeartbeatPublisher:
    """Heartbeat publisher that discards payloads."""

    async def publish(self, payload: Mapping[str, Any]) -> None:
        return None


class QueueControlChannel:
    """In-memory queue backed control channel for tests or dev mode."""

    def __init__(self) -> None:
        self._queue: asyncio.Queue[Mapping[str, Any]] = asyncio.Queue()

    async def receive(self, timeout: float = 0.0) -> Optional[Mapping[str, Any]]:
        if timeout <= 0:
            try:
                return self._queue.get_nowait()
            except asyncio.QueueEmpty:
                return None
        try:
            return await asyncio.wait_for(self._queue.get(), timeout=timeout)
        except asyncio.TimeoutError:
            return None

    async def put(self, message: Mapping[str, Any]) -> None:
        await self._queue.put(message)


class ListOrderPublisher:
    """Collects orders in-memory for assertions."""

    def __init__(self) -> None:
        self.items: List[Mapping[str, Any]] = []

    async def publish(self, intent: Mapping[str, Any]) -> None:
        self.items.append(dict(intent))


class QueueMarketDataClient:
    """Feeds market data snapshots from an asyncio.Queue."""

    def __init__(self) -> None:
        self._queue: asyncio.Queue[Mapping[str, Any]] = asyncio.Queue()

    async def fetch(self) -> Mapping[str, Any]:
        return await self._queue.get()

    async def put(self, payload: Mapping[str, Any]) -> None:
        await self._queue.put(payload)


class HeartbeatBuffer:
    """Captures heartbeat payloads for testing."""

    def __init__(self) -> None:
        self.items: List[Mapping[str, Any]] = []

    async def publish(self, payload: Mapping[str, Any]) -> None:
        self.items.append(dict(payload))


async def ensure_async(value: Any) -> Any:
    """
    If `value` is awaitable, awaits it; otherwise returns the value.
    Convenient for allowing synchronous implementations inside async code.
    """
    if asyncio.iscoroutine(value) or isinstance(value, asyncio.Future):
        return await value
    return value
